<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assemble Timeline - Content Tools</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        .app {
            display: grid;
            grid-template-columns: 400px 1fr;
            grid-template-rows: auto 1fr;
            height: 100vh;
            gap: 0;
            overflow: hidden;
        }

        .header {
            grid-column: 1 / -1;
            background: #16213e;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #2a2a4a;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #4cc9f0;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .save-status {
            font-size: 12px;
            color: #888;
            min-width: 80px;
            text-align: right;
        }

        .save-status.unsaved {
            color: #f6ad55;
        }

        .save-status.saved {
            color: #48bb78;
        }

        .btn {
            background: #4cc9f0;
            color: #0f0f1a;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #3aa8d8;
        }

        .btn-success {
            background: #48bb78;
        }

        .btn-success:hover {
            background: #38a169;
        }

        .btn-secondary {
            background: #2a2a4a;
            color: #eee;
        }

        .btn-secondary:hover {
            background: #3a3a5a;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 11px;
        }

        /* Left Panel */
        .left-panel {
            display: flex;
            flex-direction: column;
            border-right: 1px solid #2a2a4a;
            min-height: 0;
            overflow: hidden;
        }

        .video-section {
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border-bottom: 1px solid #2a2a4a;
            background: #0f0f1a;
        }

        .video-section.hidden {
            display: none;
        }

        #mainVideo {
            max-width: 100%;
            max-height: 350px;
            background: #000;
            border-radius: 8px;
        }

        .video-info {
            margin-top: 12px;
            text-align: center;
        }

        .video-info-title {
            font-size: 14px;
            font-weight: 600;
            color: #4cc9f0;
        }

        .video-info-time {
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        .editor-header {
            padding: 10px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #16213e;
            border-bottom: 1px solid #2a2a4a;
        }

        .editor-title {
            font-size: 13px;
            font-weight: 600;
            color: #eee;
        }

        .editor-actions {
            display: flex;
            gap: 6px;
        }

        .clip-pool {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            background: #16213e;
        }

        .panel-header {
            padding: 10px 16px;
            border-bottom: 1px solid #2a2a4a;
        }

        .panel-header h2 {
            font-size: 12px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .clip-pool-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .clip-pool-list::-webkit-scrollbar {
            width: 8px;
        }

        .clip-pool-list::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        .clip-pool-list::-webkit-scrollbar-thumb {
            background: #3a3a5a;
            border-radius: 4px;
        }

        .pool-item {
            background: #0f0f1a;
            border-radius: 6px;
            padding: 10px 12px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pool-item:hover {
            background: #1a2744;
        }

        .pool-item.selected {
            background: rgba(76, 201, 240, 0.15);
            border-left: 3px solid #4cc9f0;
        }

        .pool-item-name {
            font-size: 13px;
            font-weight: 500;
            color: #eee;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .pool-item-duration {
            font-size: 11px;
            color: #888;
            margin-left: 8px;
        }

        .no-clips {
            color: #666;
            font-style: italic;
            font-size: 12px;
            padding: 16px;
            text-align: center;
        }

        /* Right Panel - Transcript Workspace */
        .transcript-workspace {
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            background: #0f0f1a;
        }

        /* Timeline Cards (Horizontal) */
        .timeline-cards {
            height: 90px;
            border-bottom: 1px solid #2a2a4a;
            overflow-x: auto;
            overflow-y: hidden;
            background: #16213e;
            flex-shrink: 0;
        }

        .timeline-cards-inner {
            display: flex;
            gap: 8px;
            padding: 10px 16px;
            height: 100%;
            align-items: center;
        }

        .timeline-cards::-webkit-scrollbar {
            height: 6px;
        }

        .timeline-cards::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        .timeline-cards::-webkit-scrollbar-thumb {
            background: #3a3a5a;
            border-radius: 3px;
        }

        .timeline-card {
            min-width: 120px;
            max-width: 160px;
            padding: 10px 12px;
            background: #0f0f1a;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            flex-shrink: 0;
            transition: all 0.2s;
        }

        .timeline-card:hover {
            background: #1a2744;
        }

        .timeline-card.selected {
            border-color: #4cc9f0;
            background: rgba(76, 201, 240, 0.1);
        }

        .timeline-card.disabled {
            opacity: 0.5;
        }

        .timeline-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .timeline-card-name {
            font-size: 12px;
            font-weight: 500;
            color: #eee;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .timeline-card-pos {
            font-size: 10px;
            color: #888;
            background: #2a2a4a;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 6px;
        }

        .timeline-card-duration {
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 11px;
            color: #666;
        }

        .timeline-empty {
            color: #666;
            font-style: italic;
            font-size: 12px;
            padding: 16px;
        }

        /* Word Layer */
        .word-layer {
            height: 70px;
            position: relative;
            overflow: hidden;
            background: #0f0f1a;
            border-bottom: 1px solid #2a2a4a;
            flex-shrink: 0;
        }

        .word-layer-inner {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            padding: 10px 0;
        }

        .word {
            position: absolute;
            top: 10px;
            height: 44px;
            background: #2a4a6a;
            border-radius: 4px;
            padding: 0 10px;
            display: flex;
            align-items: center;
            cursor: grab;
            user-select: none;
            font-size: 13px;
            color: #fff;
            white-space: nowrap;
            transition: background 0.15s;
        }

        .word:hover {
            background: #3a5a8a;
        }

        .word.dragging {
            cursor: grabbing;
            background: #4a6a9a;
            z-index: 100;
        }

        .word.active {
            background: #4cc9f0;
            color: #0f0f1a;
        }

        .word-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 10px;
            cursor: ew-resize;
            z-index: 10;
        }

        .word-handle-left {
            left: 0;
            border-radius: 4px 0 0 4px;
        }

        .word-handle-left:hover {
            background: rgba(76, 201, 240, 0.3);
        }

        .word-handle-right {
            right: 0;
            border-radius: 0 4px 4px 0;
        }

        .word-handle-right:hover {
            background: rgba(76, 201, 240, 0.3);
        }

        /* Waveform Container */
        .waveform-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .waveform-wrapper {
            flex: 1;
            position: relative;
            background: #16213e;
            overflow: hidden;
            cursor: crosshair;
        }

        .waveform-wrapper.selecting {
            cursor: crosshair;
        }

        #deleteRegionsLayer {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none;
        }

        #deleteRegionsLayer .delete-region {
            pointer-events: auto;
        }

        .selection-overlay {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(255, 100, 100, 0.3);
            border-left: 2px solid #ff6464;
            border-right: 2px solid #ff6464;
            pointer-events: none;
            z-index: 15;
        }

        .delete-region {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(255, 100, 100, 0.25);
            border-left: 1px solid #ff6464;
            border-right: 1px solid #ff6464;
            z-index: 5;
            cursor: pointer;
        }

        .delete-region:hover {
            background: rgba(255, 100, 100, 0.4);
        }

        .delete-region-label {
            position: absolute;
            top: 4px;
            left: 4px;
            font-size: 10px;
            color: #ff6464;
            background: rgba(22, 33, 62, 0.8);
            padding: 2px 6px;
            border-radius: 3px;
        }

        .waveform-scrollbar-container {
            height: 20px;
            background: #0f0f1a;
            border-top: 1px solid #2a2a4a;
            position: relative;
            flex-shrink: 0;
        }

        .waveform-scrollbar-track {
            position: absolute;
            left: 10px;
            right: 10px;
            top: 4px;
            bottom: 4px;
            background: #1a1a2e;
            border-radius: 4px;
        }

        .waveform-scrollbar-thumb {
            position: absolute;
            top: 0;
            bottom: 0;
            background: #4a4a6a;
            border-radius: 4px;
            cursor: grab;
            min-width: 30px;
        }

        .waveform-scrollbar-thumb:hover {
            background: #5a5a7a;
        }

        .waveform-scrollbar-thumb.dragging {
            background: #4cc9f0;
            cursor: grabbing;
        }

        .waveform-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
        }

        #waveformCanvas {
            display: block;
        }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #f6ad55;
            z-index: 20;
            pointer-events: none;
        }

        .waveform-zoom-info {
            position: absolute;
            bottom: 8px;
            right: 12px;
            font-size: 11px;
            color: #888;
            background: rgba(22, 33, 62, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 15;
        }

        /* Editor Info */
        .editor-info {
            padding: 12px 16px;
            background: #16213e;
            border-top: 1px solid #2a2a4a;
        }

        .editor-transcript {
            font-size: 14px;
            color: #ddd;
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .editor-times {
            display: flex;
            gap: 20px;
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 11px;
            color: #888;
        }

        .editor-times span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .editor-times strong {
            color: #4cc9f0;
        }

        .no-selection {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            color: #666;
            font-style: italic;
            font-size: 14px;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #666;
        }

        .error {
            color: #f66;
            text-align: center;
            padding: 20px;
        }

        .trim-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 12px;
            background: #4cc9f0;
            cursor: ew-resize;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .trim-handle::after {
            content: '';
            width: 4px;
            height: 30px;
            background: rgba(255,255,255,0.5);
            border-radius: 2px;
        }

        .trim-handle:hover {
            background: #3aa8d8;
        }

        .trim-handle.dragging {
            background: #48bb78;
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <h1>04 - Assemble Timeline</h1>
            <div class="header-actions">
                <span class="save-status" id="saveStatus"></span>
                <button class="btn btn-secondary btn-small" id="deleteSelectionBtn" style="display: none; background: #c53030;">Delete Region</button>
                <button class="btn btn-secondary btn-small" id="cancelSelectionBtn" style="display: none;">Cancel</button>
                <button class="btn btn-secondary btn-small" id="previewAllBtn">Preview All</button>
                <button class="btn btn-secondary btn-small" id="exportBtn">Export EDL</button>
                <button class="btn btn-success btn-small" id="saveBtn">Save</button>
            </div>
        </header>

        <section class="left-panel">
            <div class="video-section" id="videoSection">
                <video id="mainVideo" controls></video>
                <div class="video-info">
                    <div class="video-info-title" id="videoInfoTitle">No clip selected</div>
                    <div class="video-info-time" id="videoInfoTime">-</div>
                </div>
            </div>

            <div class="editor-header">
                <span class="editor-title" id="editorTitle">Select a clip</span>
                <div class="editor-actions">
                    <button class="btn btn-secondary btn-small" id="toggleEnabledBtn">Disable</button>
                </div>
            </div>

            <div class="clip-pool">
                <div class="panel-header">
                    <h2>Clip Pool</h2>
                </div>
                <div class="clip-pool-list" id="clipPoolList">
                    <div class="loading">Loading...</div>
                </div>
            </div>
        </section>

        <section class="transcript-workspace">
            <div class="timeline-cards" id="timelineCards">
                <div class="timeline-cards-inner" id="timelineCardsInner">
                    <div class="timeline-empty">Loading...</div>
                </div>
            </div>

            <div class="word-layer" id="wordLayer">
                <div class="word-layer-inner" id="wordLayerInner"></div>
            </div>

            <div class="waveform-container">
                <div class="waveform-wrapper" id="waveformWrapper">
                    <div class="waveform-canvas-container" id="waveformCanvasContainer">
                        <canvas id="waveformCanvas"></canvas>
                    </div>
                    <div id="deleteRegionsLayer"></div>
                    <div class="selection-overlay" id="selectionOverlay" style="display: none;"></div>
                    <div class="trim-handle trim-handle-start" id="trimStart"></div>
                    <div class="trim-handle trim-handle-end" id="trimEnd"></div>
                    <div class="playhead" id="playhead"></div>
                    <div class="waveform-zoom-info" id="waveformZoomInfo">1.0x</div>
                </div>
                <div class="waveform-scrollbar-container">
                    <div class="waveform-scrollbar-track" id="scrollbarTrack">
                        <div class="waveform-scrollbar-thumb" id="scrollbarThumb"></div>
                    </div>
                </div>
                <div class="editor-info">
                    <div class="editor-transcript" id="editorTranscript">-</div>
                    <div class="editor-times">
                        <span>Start: <strong id="editorStartTime">0:00.00</strong></span>
                        <span>End: <strong id="editorEndTime">0:00.00</strong></span>
                        <span>Duration: <strong id="editorDuration">0.00s</strong></span>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <script>
        let project = null;
        let waveformData = null;
        let transcript = null;
        let selectedClipId = null;
        let hasUnsavedChanges = false;
        let isDraggingTrim = null;

        // Scrollbar state
        let isDraggingScrollbar = false;
        let scrollbarDragStartX = 0;
        let scrollbarDragStartPan = 0;

        // Selection state
        let isSelecting = false;
        let selectionStartX = 0;
        let selectionStart = null;
        let selectionEnd = null;

        // Waveform zoom/pan state
        let waveformZoom = 1;
        let waveformPanX = 0;
        let waveformWidth = 0;

        // Word dragging state
        let draggingWord = null;
        let dragType = null;
        let wordDragStartX = 0;
        let wordDragStartTime = 0;
        let wordDragEndTime = 0;

        const clipPoolList = document.getElementById('clipPoolList');
        const timelineCardsInner = document.getElementById('timelineCardsInner');
        const videoSection = document.getElementById('videoSection');
        const mainVideo = document.getElementById('mainVideo');
        const videoInfoTitle = document.getElementById('videoInfoTitle');
        const videoInfoTime = document.getElementById('videoInfoTime');
        const editorTitle = document.getElementById('editorTitle');
        const editorTranscript = document.getElementById('editorTranscript');
        const editorStartTime = document.getElementById('editorStartTime');
        const editorEndTime = document.getElementById('editorEndTime');
        const editorDuration = document.getElementById('editorDuration');
        const wordLayer = document.getElementById('wordLayer');
        const wordLayerInner = document.getElementById('wordLayerInner');
        const waveformWrapper = document.getElementById('waveformWrapper');
        const waveformCanvasContainer = document.getElementById('waveformCanvasContainer');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const trimStart = document.getElementById('trimStart');
        const trimEnd = document.getElementById('trimEnd');
        const playhead = document.getElementById('playhead');
        const waveformZoomInfo = document.getElementById('waveformZoomInfo');
        const saveStatus = document.getElementById('saveStatus');
        const saveBtn = document.getElementById('saveBtn');
        const previewAllBtn = document.getElementById('previewAllBtn');
        const exportBtn = document.getElementById('exportBtn');
        const toggleEnabledBtn = document.getElementById('toggleEnabledBtn');
        const selectionOverlay = document.getElementById('selectionOverlay');
        const deleteSelectionBtn = document.getElementById('deleteSelectionBtn');
        const cancelSelectionBtn = document.getElementById('cancelSelectionBtn');
        const scrollbarTrack = document.getElementById('scrollbarTrack');
        const scrollbarThumb = document.getElementById('scrollbarThumb');
        const deleteRegionsLayer = document.getElementById('deleteRegionsLayer');

        const ctx = waveformCanvas.getContext('2d');

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        function formatTimeShort(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function formatDuration(seconds) {
            return `${seconds.toFixed(2)}s`;
        }

        function getDeleteRegions() {
            return project?.delete_regions || [];
        }

        function isInDeleteRegion(time) {
            const regions = getDeleteRegions();
            for (const region of regions) {
                if (time >= region.start && time < region.end) {
                    return region;
                }
            }
            return null;
        }

        function getNextTimeAfterDeleteRegions(time) {
            const regions = getDeleteRegions().sort((a, b) => a.start - b.start);
            let adjustedTime = time;
            for (const region of regions) {
                if (adjustedTime >= region.start && adjustedTime < region.end) {
                    adjustedTime = region.end;
                }
            }
            return adjustedTime;
        }

        function markUnsaved() {
            hasUnsavedChanges = true;
            saveStatus.textContent = 'Unsaved';
            saveStatus.className = 'save-status unsaved';
        }

        function markSaved() {
            hasUnsavedChanges = false;
            saveStatus.textContent = 'Saved';
            saveStatus.className = 'save-status saved';
            setTimeout(() => {
                saveStatus.textContent = '';
                saveStatus.className = 'save-status';
            }, 2000);
        }

        async function loadData() {
            try {
                const projectResp = await fetch('../../data/project.json');
                if (!projectResp.ok) throw new Error('No project.json found');
                project = await projectResp.json();

                const waveformResp = await fetch('../../data/waveforms.json?v=' + Date.now());
                if (!waveformResp.ok) throw new Error('No waveforms.json found. Run generate_waveforms.py first.');
                waveformData = await waveformResp.json();

                const transcriptResp = await fetch('../../data/transcript_combined.json?v=' + Date.now());
                if (!transcriptResp.ok) throw new Error('No transcript_combined.json found.');
                transcript = await transcriptResp.json();

                console.log('[Assemble] Loaded', project.clips?.length || 0, 'clips');
                console.log('[Assemble] Waveform peaks:', waveformData.total_peaks, 'duration:', waveformData.duration);
                console.log('[Assemble] Transcript segments:', transcript?.segments?.length || 0);

                initializeTimelineData();
                renderClipPool();
                renderTimelineCards();
                renderWordLayer();

                const timelineClips = getTimelineClips();
                if (timelineClips.length > 0) {
                    selectClip(timelineClips[0].id);
                }
            } catch (error) {
                console.error('[Assemble] Error loading data:', error);
                clipPoolList.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            }
        }

        function initializeTimelineData() {
            if (!project.clips) return;

            if (!project.delete_regions) {
                project.delete_regions = [];
            }

            project.clips.forEach((clip) => {
                if (clip.in_timeline === undefined) {
                    clip.in_timeline = true;
                }
                if (clip.enabled === undefined) {
                    clip.enabled = true;
                }
            });

            const getStartTime = (clip) => {
                if (clip.selected_segment?.start !== undefined) {
                    return clip.selected_segment.start;
                }
                if (clip.segments?.[0]?.start !== undefined) {
                    return clip.segments[0].start;
                }
                return Infinity;
            };

            const sortedClips = [...project.clips]
                .sort((a, b) => getStartTime(a) - getStartTime(b));

            sortedClips.forEach((clip, index) => {
                clip.timeline_position = index;
            });
        }

        function getClipById(clipId) {
            return project?.clips?.find(c => c.id === clipId);
        }

        function getEffectiveTimes(clip) {
            const seg = clip.selected_segment || clip.segments?.[0];
            if (!seg) return { start: 0, end: 0 };
            
            return {
                start: clip.trim_start ?? seg.start,
                end: clip.trim_end ?? seg.end
            };
        }

        function getTimelineClips() {
            return project?.clips
                ?.filter(c => c.in_timeline)
                .sort((a, b) => (a.timeline_position || 0) - (b.timeline_position || 0)) || [];
        }

        function getPoolClips() {
            return project?.clips?.filter(c => !c.in_timeline) || [];
        }

        function renderClipPool() {
            const timelineClips = getTimelineClips();

            if (timelineClips.length === 0) {
                clipPoolList.innerHTML = '<div class="no-clips">No clips in timeline</div>';
                return;
            }

            const html = timelineClips.map((clip, index) => {
                const times = getEffectiveTimes(clip);
                const duration = (times.end - times.start).toFixed(1);
                const isSelected = selectedClipId === clip.id;
                const isDisabled = !clip.enabled;

                return `
                    <div class="pool-item ${isSelected ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}" 
                         data-clip-id="${clip.id}">
                        <span class="pool-item-name">${index + 1}. ${clip.name}</span>
                        <span class="pool-item-duration">${duration}s</span>
                    </div>
                `;
            }).join('');

            clipPoolList.innerHTML = html;

            document.querySelectorAll('.pool-item').forEach(item => {
                item.addEventListener('click', () => {
                    selectClip(item.dataset.clipId);
                });
            });
        }

        function renderTimelineCards() {
            const timelineClips = getTimelineClips();

            if (timelineClips.length === 0) {
                timelineCardsInner.innerHTML = '<div class="timeline-empty">No clips in timeline</div>';
                return;
            }

            const html = timelineClips.map((clip, index) => {
                const times = getEffectiveTimes(clip);
                const duration = (times.end - times.start).toFixed(1);
                const isSelected = selectedClipId === clip.id;
                const isDisabled = !clip.enabled;

                return `
                    <div class="timeline-card ${isSelected ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}"
                         data-clip-id="${clip.id}">
                        <div class="timeline-card-header">
                            <span class="timeline-card-name">${clip.name}</span>
                            <span class="timeline-card-pos">${index + 1}</span>
                        </div>
                        <div class="timeline-card-duration">${duration}s</div>
                    </div>
                `;
            }).join('');

            timelineCardsInner.innerHTML = html;

            document.querySelectorAll('.timeline-card').forEach(card => {
                card.addEventListener('click', () => {
                    const clip = getClipById(card.dataset.clipId);
                    if (clip) {
                        const times = getEffectiveTimes(clip);
                        mainVideo.currentTime = times.start;
                        mainVideo.play();
                    }
                });
            });
        }

        function renderWordLayer() {
            if (!transcript?.segments) return;

            const deleteRegions = getDeleteRegions();

            let html = '';
            transcript.segments.forEach((seg, segIndex) => {
                if (!seg.words) return;
                
                seg.words.forEach((word, wordIndex) => {
                    const isDeleted = deleteRegions.some(r => 
                        word.start >= r.start && word.end <= r.end
                    );
                    if (isDeleted) return;

                    html += `
                        <div class="word" 
                             data-segment="${segIndex}" 
                             data-word="${wordIndex}"
                             data-start="${word.start}"
                             data-end="${word.end}">
                            <div class="word-handle word-handle-left"></div>
                            <span>${word.text}</span>
                            <div class="word-handle word-handle-right"></div>
                        </div>
                    `;
                });
            });

            wordLayerInner.innerHTML = html;
            positionWords();
            attachWordDragHandlers();
        }

        function positionWords() {
            if (!waveformData) return;

            const duration = waveformData.duration;
            const containerWidth = waveformWidth || wordLayer.offsetWidth;

            document.querySelectorAll('.word').forEach(wordEl => {
                const start = parseFloat(wordEl.dataset.start);
                const end = parseFloat(wordEl.dataset.end);

                const left = (start / duration) * containerWidth;
                const width = Math.max(30, ((end - start) / duration) * containerWidth);

                wordEl.style.left = left + 'px';
                wordEl.style.width = width + 'px';
            });

            syncWordLayerWithWaveform();
        }

        function syncWordLayerWithWaveform() {
            wordLayerInner.style.width = waveformWidth + 'px';
            wordLayerInner.style.transform = `translateX(${-waveformPanX}px)`;
        }

        function attachWordDragHandlers() {
            document.querySelectorAll('.word').forEach(wordEl => {
                wordEl.addEventListener('mousedown', handleWordMouseDown);
            });
        }

        function handleWordMouseDown(e) {
            const wordEl = e.target.closest('.word');
            if (!wordEl) return;

            draggingWord = wordEl;
            wordDragStartX = e.clientX;
            wordDragStartTime = parseFloat(wordEl.dataset.start);
            wordDragEndTime = parseFloat(wordEl.dataset.end);

            if (e.target.classList.contains('word-handle-left')) {
                dragType = 'left';
            } else if (e.target.classList.contains('word-handle-right')) {
                dragType = 'right';
            } else {
                dragType = 'move';
            }

            wordEl.classList.add('dragging');
            e.preventDefault();
        }

        function handleWordMouseMove(e) {
            if (!draggingWord) return;

            const deltaX = e.clientX - wordDragStartX;
            const deltaTime = (deltaX / waveformWidth) * waveformData.duration;

            const segIndex = parseInt(draggingWord.dataset.segment);
            const wordIndex = parseInt(draggingWord.dataset.word);
            const seg = transcript.segments[segIndex];
            const word = seg.words[wordIndex];

            if (dragType === 'move') {
                const duration = wordDragEndTime - wordDragStartTime;
                const newStart = Math.max(seg.start, Math.min(seg.end - duration, wordDragStartTime + deltaTime));
                word.start = newStart;
                word.end = newStart + duration;
            } else if (dragType === 'left') {
                const newStart = Math.max(seg.start, Math.min(word.end - 0.1, wordDragStartTime + deltaTime));
                if (wordIndex > 0) {
                    seg.words[wordIndex - 1].end = newStart;
                }
                word.start = newStart;
            } else if (dragType === 'right') {
                const newEnd = Math.min(seg.end, Math.max(word.start + 0.1, wordDragEndTime + deltaTime));
                if (wordIndex < seg.words.length - 1) {
                    seg.words[wordIndex + 1].start = newEnd;
                }
                word.end = newEnd;
            }

            draggingWord.dataset.start = word.start;
            draggingWord.dataset.end = word.end;
            
            positionWords();
            markUnsaved();
        }

        function handleWordMouseUp() {
            if (draggingWord) {
                draggingWord.classList.remove('dragging');
                draggingWord = null;
                dragType = null;
            }
        }

        document.addEventListener('mousemove', handleWordMouseMove);
        document.addEventListener('mouseup', handleWordMouseUp);

        function selectClip(clipId) {
            selectedClipId = clipId;
            renderClipPool();
            renderTimelineCards();
            renderEditor();
            loadVideoPreview(clipId);
        }

        function renderEditor() {
            if (!selectedClipId) {
                videoSection.classList.add('hidden');
                editorTranscript.textContent = '-';
                editorStartTime.textContent = '-';
                editorEndTime.textContent = '-';
                editorDuration.textContent = '-';
                return;
            }

            const clip = getClipById(selectedClipId);
            const seg = clip?.selected_segment || clip?.segments?.[0];
            if (!clip || !seg) {
                videoSection.classList.add('hidden');
                return;
            }

            videoSection.classList.remove('hidden');

            const times = getEffectiveTimes(clip);
            const duration = times.end - times.start;

            editorTitle.textContent = clip.name;
            editorTranscript.textContent = seg.text || '-';
            editorStartTime.textContent = formatTime(times.start);
            editorEndTime.textContent = formatTime(times.end);
            editorDuration.textContent = formatDuration(duration);

            toggleEnabledBtn.textContent = clip.enabled ? 'Disable' : 'Enable';
            toggleEnabledBtn.classList.toggle('btn-success', !clip.enabled);

            requestAnimationFrame(() => {
                renderFullWaveform(clip);
            });
        }

        function renderFullWaveform(clip) {
            const rect = waveformWrapper.getBoundingClientRect();
            
            if (rect.width === 0 || rect.height === 0) {
                requestAnimationFrame(() => renderFullWaveform(clip));
                return;
            }

            const peaks = waveformData.peaks;
            const duration = waveformData.duration;

            waveformWidth = rect.width * waveformZoom;
            waveformCanvasContainer.style.width = waveformWidth + 'px';

            waveformCanvas.width = waveformWidth * window.devicePixelRatio;
            waveformCanvas.height = rect.height * window.devicePixelRatio;
            waveformCanvas.style.width = waveformWidth + 'px';
            waveformCanvas.style.height = rect.height + 'px';

            waveformCanvasContainer.style.transform = `translateX(${-waveformPanX}px)`;

            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, waveformWidth, rect.height);

            const peaksPerPixel = peaks.length / waveformWidth;
            const centerY = rect.height / 2;

            ctx.fillStyle = '#2a4a6a';
            for (let x = 0; x < waveformWidth; x++) {
                const peakIndex = Math.floor(x * peaksPerPixel);
                const peak = peaks[peakIndex] || 0;
                const barHeight = peak * rect.height * 0.95;
                ctx.fillRect(x, centerY - barHeight / 2, 1, barHeight);
            }

            if (clip) {
                const times = getEffectiveTimes(clip);
                const startX = (times.start / duration) * waveformWidth;
                const endX = (times.end / duration) * waveformWidth;

                ctx.fillStyle = 'rgba(15, 15, 26, 0.6)';
                ctx.fillRect(0, 0, startX, rect.height);
                ctx.fillRect(endX, 0, waveformWidth - endX, rect.height);

                ctx.strokeStyle = '#4cc9f0';
                ctx.lineWidth = 2;
                ctx.strokeRect(startX, 0, endX - startX, rect.height);

                trimStart.style.left = (startX - waveformPanX) + 'px';
                trimEnd.style.left = (endX - 12 - waveformPanX) + 'px';
            }

            renderDeleteRegionsVisual();
            updateScrollbar();

            waveformZoomInfo.textContent = `${waveformZoom.toFixed(1)}x`;
            updatePlayheadPosition();
            positionWords();
        }

        function renderDeleteRegionsVisual() {
            const duration = waveformData.duration;
            const deleteRegions = getDeleteRegions();

            let html = '';
            deleteRegions.forEach((region, index) => {
                const startX = (region.start / duration) * waveformWidth;
                const endX = (region.end / duration) * waveformWidth;

                html += `
                    <div class="delete-region" 
                         data-delete-id="${region.id}"
                         style="left: ${startX}px; width: ${endX - startX}px; transform: translateX(${-waveformPanX}px);">
                        <span class="delete-region-label">Deleted</span>
                    </div>
                `;
            });

            deleteRegionsLayer.innerHTML = html;

            document.querySelectorAll('.delete-region').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const deleteId = el.dataset.deleteId;
                    removeDeleteRegion(deleteId);
                });
            });
        }

        function updateScrollbar() {
            const containerWidth = scrollbarTrack.offsetWidth;
            const visibleRatio = waveformWrapper.offsetWidth / waveformWidth;
            const thumbWidth = Math.max(30, containerWidth * visibleRatio);
            const maxThumbPan = containerWidth - thumbWidth;
            const maxWaveformPan = waveformWidth - waveformWrapper.offsetWidth;
            const thumbPan = maxWaveformPan > 0 ? (waveformPanX / maxWaveformPan) * maxThumbPan : 0;

            scrollbarThumb.style.width = thumbWidth + 'px';
            scrollbarThumb.style.left = thumbPan + 'px';
        }

        function updatePlayheadPosition() {
            if (!mainVideo.timeStart && mainVideo.timeStart !== 0) return;
            if (!waveformData) return;

            const duration = waveformData.duration;
            const currentTime = mainVideo.currentTime;
            const x = (currentTime / duration) * waveformWidth;

            playhead.style.left = (x - waveformPanX) + 'px';
        }

        function highlightCurrentWord(time) {
            document.querySelectorAll('.word.active').forEach(el => el.classList.remove('active'));

            if (!transcript?.segments) return;

            for (const seg of transcript.segments) {
                if (!seg.words) continue;
                for (const word of seg.words) {
                    if (time >= word.start && time <= word.end) {
                        const wordEl = document.querySelector(
                            `.word[data-segment="${transcript.segments.indexOf(seg)}"][data-word="${seg.words.indexOf(word)}"]`
                        );
                        if (wordEl) {
                            wordEl.classList.add('active');
                        }
                        return;
                    }
                }
            }
        }

        waveformWrapper.addEventListener('wheel', (e) => {
            e.preventDefault();

            const rect = waveformWrapper.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const oldZoom = waveformZoom;

            if (e.deltaY < 0) {
                waveformZoom = Math.min(50, waveformZoom * 1.25);
            } else {
                waveformZoom = Math.max(1, waveformZoom / 1.25);
            }

            const zoomRatio = waveformZoom / oldZoom;
            waveformWidth = rect.width * waveformZoom;
            waveformPanX = mouseX - (mouseX - waveformPanX) * zoomRatio;

            const maxPan = Math.max(0, waveformWidth - rect.width);
            waveformPanX = Math.max(0, Math.min(maxPan, waveformPanX));

            const clip = selectedClipId ? getClipById(selectedClipId) : null;
            renderFullWaveform(clip);
        }, { passive: false });

        waveformWrapper.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('trim-handle')) return;
            if (e.target.closest('.word')) return;
            if (e.target.closest('.delete-region')) return;

            const rect = waveformWrapper.getBoundingClientRect();
            const x = e.clientX - rect.left + waveformPanX;
            const time = (x / waveformWidth) * waveformData.duration;

            isSelecting = true;
            selectionStartX = e.clientX;
            selectionStart = time;
            selectionEnd = time;

            selectionOverlay.style.display = 'block';
            updateSelectionOverlay();
        });

        function updateSelectionOverlay() {
            if (selectionStart === null || selectionEnd === null) return;

            const minTime = Math.min(selectionStart, selectionEnd);
            const maxTime = Math.max(selectionStart, selectionEnd);

            const startX = (minTime / waveformData.duration) * waveformWidth - waveformPanX;
            const endX = (maxTime / waveformData.duration) * waveformWidth - waveformPanX;

            selectionOverlay.style.left = startX + 'px';
            selectionOverlay.style.width = (endX - startX) + 'px';
        }

        document.addEventListener('mousemove', (e) => {
            if (isSelecting) {
                const rect = waveformWrapper.getBoundingClientRect();
                const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left)) + waveformPanX;
                selectionEnd = (x / waveformWidth) * waveformData.duration;
                updateSelectionOverlay();
            }
        });

        document.addEventListener('mouseup', () => {
            if (isSelecting) {
                isSelecting = false;

                if (selectionStart !== null && selectionEnd !== null) {
                    const duration = Math.abs(selectionEnd - selectionStart);
                    if (duration > 0.1) {
                        deleteSelectionBtn.style.display = 'inline-block';
                        cancelSelectionBtn.style.display = 'inline-block';
                    } else {
                        clearSelection();
                    }
                }
            }
        });

        function clearSelection() {
            selectionStart = null;
            selectionEnd = null;
            selectionOverlay.style.display = 'none';
            deleteSelectionBtn.style.display = 'none';
            cancelSelectionBtn.style.display = 'none';
        }

        cancelSelectionBtn.addEventListener('click', clearSelection);

        deleteSelectionBtn.addEventListener('click', () => {
            if (selectionStart === null || selectionEnd === null) return;

            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);

            const region = {
                id: `del_${Date.now()}`,
                start: start,
                end: end
            };

            project.delete_regions.push(region);
            markUnsaved();
            clearSelection();
            renderDeleteRegionsVisual();
            renderWordLayer();
        });

        function removeDeleteRegion(regionId) {
            project.delete_regions = project.delete_regions.filter(r => r.id !== regionId);
            markUnsaved();
            renderDeleteRegionsVisual();
            renderWordLayer();
        }

        scrollbarThumb.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isDraggingScrollbar = true;
            scrollbarDragStartX = e.clientX;
            scrollbarDragStartPan = waveformPanX;
            scrollbarThumb.classList.add('dragging');
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingScrollbar) {
                const containerWidth = scrollbarTrack.offsetWidth;
                const visibleRatio = waveformWrapper.offsetWidth / waveformWidth;
                const thumbWidth = Math.max(30, containerWidth * visibleRatio);
                const maxThumbPan = containerWidth - thumbWidth;
                const maxWaveformPan = waveformWidth - waveformWrapper.offsetWidth;

                const deltaX = e.clientX - scrollbarDragStartX;
                const thumbDelta = (deltaX / maxThumbPan) * maxWaveformPan;
                waveformPanX = Math.max(0, Math.min(maxWaveformPan, scrollbarDragStartPan + thumbDelta));

                const clip = selectedClipId ? getClipById(selectedClipId) : null;
                renderFullWaveform(clip);
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDraggingScrollbar) {
                isDraggingScrollbar = false;
                scrollbarThumb.classList.remove('dragging');
            }
        });

        function loadVideoPreview(clipId) {
            const clip = getClipById(clipId);
            const seg = clip?.selected_segment || clip?.segments?.[0];
            if (!clip || !seg) return;

            const times = getEffectiveTimes(clip);
            mainVideo.src = `../../data/video_combined.mp4#t=${times.start}`;

            videoInfoTitle.textContent = clip.name;
            videoInfoTime.textContent = `${formatTimeShort(times.start)} - ${formatTimeShort(times.end)}`;

            mainVideo.timeStart = times.start;
            mainVideo.timeEnd = times.end;
        }

        mainVideo.addEventListener('timeupdate', () => {
            const start = mainVideo.timeStart;
            const end = mainVideo.timeEnd;

            const deleteRegion = isInDeleteRegion(mainVideo.currentTime);
            if (deleteRegion) {
                if (deleteRegion.end >= end) {
                    mainVideo.pause();
                    mainVideo.currentTime = start;
                } else {
                    mainVideo.currentTime = deleteRegion.end;
                }
                return;
            }

            if (mainVideo.currentTime >= end) {
                mainVideo.pause();
                mainVideo.currentTime = start;
            }

            updatePlayheadPosition();
            highlightCurrentWord(mainVideo.currentTime);
        });

        trimStart.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            isDraggingTrim = 'start';
            trimStart.classList.add('dragging');
        });

        trimEnd.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            isDraggingTrim = 'end';
            trimEnd.classList.add('dragging');
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingTrim || !selectedClipId) return;

            const clip = getClipById(selectedClipId);
            if (!clip) return;

            const rect = waveformWrapper.getBoundingClientRect();
            const x = e.clientX - rect.left + waveformPanX;

            const duration = waveformData.duration;
            const ratio = Math.max(0, Math.min(1, x / waveformWidth));
            const newTime = ratio * duration;

            const times = getEffectiveTimes(clip);

            if (isDraggingTrim === 'start') {
                clip.trim_start = Math.max(0, Math.min(newTime, times.end - 0.1));
            } else {
                clip.trim_end = Math.min(duration, Math.max(newTime, times.start + 0.1));
            }

            markUnsaved();
            renderFullWaveform(clip);
        });

        document.addEventListener('mouseup', () => {
            if (isDraggingTrim) {
                isDraggingTrim = null;
                trimStart.classList.remove('dragging');
                trimEnd.classList.remove('dragging');

                if (selectedClipId) {
                    loadVideoPreview(selectedClipId);
                    renderEditor();
                }
            }
        });

        toggleEnabledBtn.addEventListener('click', () => {
            if (!selectedClipId) return;

            const clip = getClipById(selectedClipId);
            if (!clip) return;

            clip.enabled = !clip.enabled;

            markUnsaved();
            renderClipPool();
            renderTimelineCards();
            renderEditor();
        });

        previewAllBtn.addEventListener('click', () => {
            const timelineClips = getTimelineClips().filter(c => c.enabled);
            if (timelineClips.length === 0) {
                alert('No clips in timeline to preview');
                return;
            }

            previewQueue = timelineClips;
            previewIndex = 0;
            playNextInQueue();
        });

        let previewQueue = [];
        let previewIndex = 0;

        function playNextInQueue() {
            if (previewIndex >= previewQueue.length) {
                previewQueue = [];
                previewIndex = 0;
                return;
            }

            const clip = previewQueue[previewIndex];
            const times = getEffectiveTimes(clip);

            selectedClipId = clip.id;
            renderClipPool();
            renderTimelineCards();
            renderEditor();

            mainVideo.src = `../../data/video_combined.mp4#t=${times.start}`;
            mainVideo.timeStart = times.start;
            mainVideo.timeEnd = times.end;

            mainVideo.oncanplay = () => {
                mainVideo.play();
            };

            mainVideo.onended = () => {
                previewIndex++;
                playNextInQueue();
            };
        }

        function exportEDL() {
            const timelineClips = getTimelineClips().filter(c => c.enabled);
            if (timelineClips.length === 0) {
                alert('No clips to export');
                return;
            }

            const deleteRegions = getDeleteRegions().sort((a, b) => a.start - b.start);

            let edl = 'TITLE: Content Tools Export\n';
            edl += 'FCM: NON-DROP FRAME\n\n';

            let timelineTime = 0;
            let clipIndex = 1;

            timelineClips.forEach((clip) => {
                const times = getEffectiveTimes(clip);
                const seg = clip.selected_segment || clip.segments?.[0];

                const segments = getClipSegmentsExcludingDeletes(times.start, times.end, deleteRegions);

                segments.forEach((seg_times) => {
                    const duration = seg_times.end - seg_times.start;

                    const clipIn = formatEDLTime(seg_times.start);
                    const clipOut = formatEDLTime(seg_times.end);
                    const recIn = formatEDLTime(timelineTime);
                    const recOut = formatEDLTime(timelineTime + duration);

                    edl += `${String(clipIndex).padStart(3, '0')}  AX       AA/V  C        ${clipIn} ${clipOut} ${recIn} ${recOut}\n`;
                    edl += `* FROM CLIP NAME: ${clip.name}\n`;
                    edl += `* COMMENT: ${seg?.text?.substring(0, 60) || ''}\n\n`;

                    timelineTime += duration;
                    clipIndex++;
                });
            });

            const blob = new Blob([edl], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'assembly.edl';
            a.click();
            URL.revokeObjectURL(url);
        }

        function getClipSegmentsExcludingDeletes(clipStart, clipEnd, deleteRegions) {
            const relevantDeletes = deleteRegions.filter(r => 
                r.start < clipEnd && r.end > clipStart
            );

            if (relevantDeletes.length === 0) {
                return [{ start: clipStart, end: clipEnd }];
            }

            const segments = [];
            let currentStart = clipStart;

            relevantDeletes.forEach(del => {
                if (del.start > currentStart) {
                    segments.push({ start: currentStart, end: Math.min(del.start, clipEnd) });
                }
                currentStart = Math.max(currentStart, del.end);
            });

            if (currentStart < clipEnd) {
                segments.push({ start: currentStart, end: clipEnd });
            }

            return segments;
        }

        function formatEDLTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const f = Math.floor((seconds % 1) * 30);
            return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}:${String(f).padStart(2, '0')}`;
        }

        exportBtn.addEventListener('click', exportEDL);

        async function saveProject() {
            try {
                const projectData = {
                    ...project,
                    transcript: transcript
                };

                const response = await fetch('../../data/project.json', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(projectData, null, 2)
                });

                if (!response.ok) {
                    throw new Error('Failed to save');
                }

                markSaved();
                console.log('[Assemble] Project saved with word timings');
            } catch (e) {
                const projectData = {
                    ...project,
                    transcript: transcript
                };
                const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'project.json';
                a.click();
                URL.revokeObjectURL(url);
                markSaved();
            }
        }

        saveBtn.addEventListener('click', saveProject);

        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        window.addEventListener('resize', () => {
            if (selectedClipId) {
                const clip = getClipById(selectedClipId);
                if (clip) {
                    requestAnimationFrame(() => renderFullWaveform(clip));
                }
            } else if (waveformData) {
                renderFullWaveform(null);
            }
        });

        loadData();
    </script>
</body>
</html>
