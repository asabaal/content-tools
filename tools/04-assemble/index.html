<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assemble Timeline - Content Tools</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        .app {
            display: grid;
            grid-template-columns: 400px 1fr;
            grid-template-rows: auto 1fr;
            height: 100vh;
            gap: 0;
            overflow: hidden;
        }

        .header {
            grid-column: 1 / -1;
            background: #16213e;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #2a2a4a;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #4cc9f0;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .save-status {
            font-size: 12px;
            color: #888;
            min-width: 80px;
            text-align: right;
        }

        .save-status.unsaved {
            color: #f6ad55;
        }

        .save-status.saved {
            color: #48bb78;
        }

        .btn {
            background: #4cc9f0;
            color: #0f0f1a;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #3aa8d8;
        }

        .btn-success {
            background: #48bb78;
        }

        .btn-success:hover {
            background: #38a169;
        }

        .btn-secondary {
            background: #2a2a4a;
            color: #eee;
        }

        .btn-secondary:hover {
            background: #3a3a5a;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 11px;
        }

        /* Left Panel */
        .left-panel {
            display: flex;
            flex-direction: column;
            border-right: 1px solid #2a2a4a;
            min-height: 0;
            overflow: hidden;
        }

        .video-section {
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border-bottom: 1px solid #2a2a4a;
            background: #0f0f1a;
        }

        .video-section.hidden {
            display: none;
        }

        #mainVideo {
            max-width: 100%;
            max-height: 350px;
            background: #000;
            border-radius: 8px;
        }

        .video-info {
            margin-top: 12px;
            text-align: center;
        }

        .video-info-title {
            font-size: 14px;
            font-weight: 600;
            color: #4cc9f0;
        }

        .video-info-time {
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        .editor-header {
            padding: 10px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #16213e;
            border-bottom: 1px solid #2a2a4a;
        }

        .editor-title {
            font-size: 13px;
            font-weight: 600;
            color: #eee;
        }

        .editor-actions {
            display: flex;
            gap: 6px;
        }

        .clip-pool {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            background: #16213e;
        }

        .panel-header {
            padding: 10px 16px;
            border-bottom: 1px solid #2a2a4a;
        }

        .panel-header h2 {
            font-size: 12px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .clip-pool-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .clip-pool-list::-webkit-scrollbar {
            width: 8px;
        }

        .clip-pool-list::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        .clip-pool-list::-webkit-scrollbar-thumb {
            background: #3a3a5a;
            border-radius: 4px;
        }

        .pool-item {
            background: #0f0f1a;
            border-radius: 6px;
            padding: 10px 12px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pool-item:hover {
            background: #1a2744;
        }

        .pool-item.selected {
            background: rgba(76, 201, 240, 0.15);
            border-left: 3px solid #4cc9f0;
        }

        .pool-item-name {
            font-size: 13px;
            font-weight: 500;
            color: #eee;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .pool-item-duration {
            font-size: 11px;
            color: #888;
            margin-left: 8px;
        }

        .no-clips {
            color: #666;
            font-style: italic;
            font-size: 12px;
            padding: 16px;
            text-align: center;
        }

        /* Right Panel - Transcript Workspace */
        .transcript-workspace {
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            background: #0f0f1a;
        }

        /* Timeline Cards (Horizontal) */
        .timeline-cards {
            height: 90px;
            border-bottom: 1px solid #2a2a4a;
            overflow-x: auto;
            overflow-y: hidden;
            background: #16213e;
            flex-shrink: 0;
        }

        .timeline-cards-inner {
            display: flex;
            gap: 8px;
            padding: 10px 16px;
            height: 100%;
            align-items: center;
        }

        .timeline-cards::-webkit-scrollbar {
            height: 6px;
        }

        .timeline-cards::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        .timeline-cards::-webkit-scrollbar-thumb {
            background: #3a3a5a;
            border-radius: 3px;
        }

        .timeline-card {
            min-width: 120px;
            max-width: 160px;
            padding: 10px 12px;
            background: #0f0f1a;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            flex-shrink: 0;
            transition: all 0.2s;
        }

        .timeline-card:hover {
            background: #1a2744;
        }

        .timeline-card.selected {
            border-color: #4cc9f0;
            background: rgba(76, 201, 240, 0.1);
        }

        .timeline-card.disabled {
            opacity: 0.5;
        }

        .timeline-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .timeline-card-name {
            font-size: 12px;
            font-weight: 500;
            color: #eee;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .timeline-card-pos {
            font-size: 10px;
            color: #888;
            background: #2a2a4a;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 6px;
        }

        .timeline-card-duration {
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 11px;
            color: #666;
        }

        .timeline-empty {
            color: #666;
            font-style: italic;
            font-size: 12px;
            padding: 16px;
        }

        /* Word Layer */
        .word-layer {
            height: 70px;
            position: relative;
            overflow: hidden;
            background: #0f0f1a;
            border-bottom: 1px solid #2a2a4a;
            flex-shrink: 0;
        }

        .word-layer-inner {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            padding: 10px 0;
        }

        .word {
            position: absolute;
            top: 10px;
            height: 44px;
            background: #2a4a6a;
            border-radius: 4px;
            padding: 0 10px;
            display: flex;
            align-items: center;
            cursor: grab;
            user-select: none;
            font-size: 13px;
            color: #fff;
            white-space: nowrap;
            transition: background 0.15s;
        }

        .word:hover {
            background: #3a5a8a;
        }

        .word.dragging {
            cursor: grabbing;
            background: #4a6a9a;
            z-index: 100;
        }

        .word.active {
            background: #4cc9f0;
            color: #0f0f1a;
        }

        .word-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 10px;
            cursor: ew-resize;
            z-index: 10;
        }

        .word-handle-left {
            left: 0;
            border-radius: 4px 0 0 4px;
        }

        .word-handle-left:hover {
            background: rgba(76, 201, 240, 0.3);
        }

        .word-handle-right {
            right: 0;
            border-radius: 0 4px 4px 0;
        }

        .word-handle-right:hover {
            background: rgba(76, 201, 240, 0.3);
        }

        /* Waveform Container */
        .waveform-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .waveform-wrapper {
            flex: 1;
            position: relative;
            background: #16213e;
            overflow: hidden;
            cursor: crosshair;
        }

        .waveform-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
        }

        #waveformCanvas {
            display: block;
        }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #f6ad55;
            z-index: 20;
            pointer-events: none;
        }

        .waveform-zoom-info {
            position: absolute;
            bottom: 8px;
            right: 12px;
            font-size: 11px;
            color: #888;
            background: rgba(22, 33, 62, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 15;
        }

        .waveform-scrollbar {
            height: 16px;
            background: #0f0f1a;
            border-top: 1px solid #2a2a4a;
            position: relative;
            flex-shrink: 0;
        }

        .waveform-scrollbar-track {
            position: absolute;
            top: 3px;
            bottom: 3px;
            left: 8px;
            right: 8px;
            background: #1a1a2e;
            border-radius: 4px;
        }

        .waveform-scrollbar-thumb {
            position: absolute;
            top: 0;
            bottom: 0;
            background: #3a5a8a;
            border-radius: 4px;
            cursor: grab;
            min-width: 20px;
            transition: background 0.15s;
        }

        .waveform-scrollbar-thumb:hover {
            background: #4a6a9a;
        }

        .waveform-scrollbar-thumb.dragging {
            background: #4cc9f0;
            cursor: grabbing;
        }

        .waveform-selection {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(240, 80, 80, 0.3);
            border: 1px solid #f05050;
            pointer-events: none;
            z-index: 25;
            display: none;
        }

        .deleted-region {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(240, 80, 80, 0.35);
            cursor: pointer;
            z-index: 5;
        }

        .deleted-region:hover {
            background: rgba(240, 80, 80, 0.5);
        }

        /* Editor Info */
        .editor-info {
            padding: 12px 16px;
            background: #16213e;
            border-top: 1px solid #2a2a4a;
        }

        .editor-transcript {
            font-size: 14px;
            color: #ddd;
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .editor-times {
            display: flex;
            gap: 20px;
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 11px;
            color: #888;
        }

        .editor-times span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .editor-times strong {
            color: #4cc9f0;
        }

        .no-selection {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            color: #666;
            font-style: italic;
            font-size: 14px;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #666;
        }

        .error {
            color: #f66;
            text-align: center;
            padding: 20px;
        }

        .trim-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 12px;
            background: #4cc9f0;
            cursor: ew-resize;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .trim-handle::after {
            content: '';
            width: 4px;
            height: 30px;
            background: rgba(255,255,255,0.5);
            border-radius: 2px;
        }

        .trim-handle:hover {
            background: #3aa8d8;
        }

        .trim-handle.dragging {
            background: #48bb78;
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <h1>04 - Assemble Timeline</h1>
            <div class="header-actions">
                <span class="save-status" id="saveStatus"></span>
                <button class="btn btn-secondary btn-small" id="previewAllBtn">Preview All</button>
                <button class="btn btn-secondary btn-small" id="exportBtn">Export EDL</button>
                <button class="btn btn-success btn-small" id="saveBtn">Save</button>
            </div>
        </header>

        <section class="left-panel">
            <div class="video-section" id="videoSection">
                <video id="mainVideo" controls></video>
                <div class="video-info">
                    <div class="video-info-title" id="videoInfoTitle">No clip selected</div>
                    <div class="video-info-time" id="videoInfoTime">-</div>
                </div>
            </div>

            <div class="editor-header">
                <span class="editor-title" id="editorTitle">Select a clip</span>
                <div class="editor-actions">
                    <button class="btn btn-secondary btn-small" id="splitBtn">Split</button>
                    <button class="btn btn-secondary btn-small" id="toggleEnabledBtn">Disable</button>
                </div>
            </div>

            <div class="clip-pool">
                <div class="panel-header">
                    <h2>Clip Pool</h2>
                </div>
                <div class="clip-pool-list" id="clipPoolList">
                    <div class="loading">Loading...</div>
                </div>
            </div>
        </section>

        <section class="transcript-workspace">
            <div class="timeline-cards" id="timelineCards">
                <div class="timeline-cards-inner" id="timelineCardsInner">
                    <div class="timeline-empty">Loading...</div>
                </div>
            </div>

            <div class="word-layer" id="wordLayer">
                <div class="word-layer-inner" id="wordLayerInner"></div>
            </div>

            <div class="waveform-container">
                <div class="waveform-wrapper" id="waveformWrapper">
                    <div class="waveform-canvas-container" id="waveformCanvasContainer">
                        <canvas id="waveformCanvas"></canvas>
                    </div>
                    <div class="trim-handle trim-handle-start" id="trimStart"></div>
                    <div class="trim-handle trim-handle-end" id="trimEnd"></div>
                    <div class="playhead" id="playhead"></div>
                    <div class="waveform-zoom-info" id="waveformZoomInfo">1.0x</div>
                    <div class="waveform-selection" id="waveformSelection"></div>
                </div>
                <div class="waveform-scrollbar" id="waveformScrollbar">
                    <div class="waveform-scrollbar-track">
                        <div class="waveform-scrollbar-thumb" id="waveformScrollbarThumb"></div>
                    </div>
                </div>
                <div class="editor-info">
                    <div class="editor-transcript" id="editorTranscript">-</div>
                    <div class="editor-times">
                        <span>Start: <strong id="editorStartTime">0:00.00</strong></span>
                        <span>End: <strong id="editorEndTime">0:00.00</strong></span>
                        <span>Duration: <strong id="editorDuration">0.00s</strong></span>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <script>
        let project = null;
        let waveformData = null;
        let transcript = null;
        let selectedClipId = null;
        let hasUnsavedChanges = false;
        let isDraggingTrim = null;
        let previewQueue = [];
        let previewIndex = 0;

        // Waveform zoom/pan state
        let waveformZoom = 1;
        let waveformPanX = 0;
        let waveformWidth = 0;

        // Word dragging state
        let draggingWord = null;
        let dragType = null;
        let wordDragStartX = 0;
        let wordDragStartTime = 0;
        let wordDragEndTime = 0;

        // Scrollbar state
        let isDraggingScrollbar = false;
        let scrollbarDragStartX = 0;
        let scrollbarDragStartPan = 0;

        // Selection state
        let isSelecting = false;
        let selectionStartX = 0;
        let selectionStartTime = 0;
        let selectionEndTime = 0;

        const clipPoolList = document.getElementById('clipPoolList');
        const timelineCardsInner = document.getElementById('timelineCardsInner');
        const videoSection = document.getElementById('videoSection');
        const mainVideo = document.getElementById('mainVideo');
        const videoInfoTitle = document.getElementById('videoInfoTitle');
        const videoInfoTime = document.getElementById('videoInfoTime');
        const editorTitle = document.getElementById('editorTitle');
        const editorTranscript = document.getElementById('editorTranscript');
        const editorStartTime = document.getElementById('editorStartTime');
        const editorEndTime = document.getElementById('editorEndTime');
        const editorDuration = document.getElementById('editorDuration');
        const wordLayer = document.getElementById('wordLayer');
        const wordLayerInner = document.getElementById('wordLayerInner');
        const waveformWrapper = document.getElementById('waveformWrapper');
        const waveformCanvasContainer = document.getElementById('waveformCanvasContainer');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const trimStart = document.getElementById('trimStart');
        const trimEnd = document.getElementById('trimEnd');
        const playhead = document.getElementById('playhead');
        const waveformZoomInfo = document.getElementById('waveformZoomInfo');
        const waveformScrollbar = document.getElementById('waveformScrollbar');
        const waveformScrollbarThumb = document.getElementById('waveformScrollbarThumb');
        const waveformSelection = document.getElementById('waveformSelection');
        const saveStatus = document.getElementById('saveStatus');
        const saveBtn = document.getElementById('saveBtn');
        const previewAllBtn = document.getElementById('previewAllBtn');
        const exportBtn = document.getElementById('exportBtn');
        const splitBtn = document.getElementById('splitBtn');
        const toggleEnabledBtn = document.getElementById('toggleEnabledBtn');

        const ctx = waveformCanvas.getContext('2d');

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        function formatTimeShort(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function formatDuration(seconds) {
            return `${seconds.toFixed(2)}s`;
        }

        function markUnsaved() {
            hasUnsavedChanges = true;
            saveStatus.textContent = 'Unsaved';
            saveStatus.className = 'save-status unsaved';
        }

        function markSaved() {
            hasUnsavedChanges = false;
            saveStatus.textContent = 'Saved';
            saveStatus.className = 'save-status saved';
            setTimeout(() => {
                saveStatus.textContent = '';
                saveStatus.className = 'save-status';
            }, 2000);
        }

        async function loadData() {
            try {
                const projectResp = await fetch('../../data/project.json');
                if (!projectResp.ok) throw new Error('No project.json found');
                project = await projectResp.json();

                const waveformResp = await fetch('../../data/waveforms.json?v=' + Date.now());
                if (!waveformResp.ok) throw new Error('No waveforms.json found. Run generate_waveforms.py first.');
                waveformData = await waveformResp.json();

                const transcriptResp = await fetch('../../data/transcript_combined.json?v=' + Date.now());
                if (!transcriptResp.ok) throw new Error('No transcript_combined.json found.');
                transcript = await transcriptResp.json();

                console.log('[Assemble] Loaded', project.clips?.length || 0, 'clips');
                console.log('[Assemble] Waveform peaks:', waveformData.total_peaks, 'duration:', waveformData.duration);
                console.log('[Assemble] Transcript segments:', transcript?.segments?.length || 0);

                initializeTimelineData();
                renderClipPool();
                renderTimelineCards();
                renderWordLayer();

                const timelineClips = getTimelineClips();
                if (timelineClips.length > 0) {
                    selectClip(timelineClips[0].id);
                }
            } catch (error) {
                console.error('[Assemble] Error loading data:', error);
                clipPoolList.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            }
        }

        function initializeTimelineData() {
            if (!project.clips) return;

            project.clips.forEach((clip) => {
                if (clip.in_timeline === undefined) {
                    clip.in_timeline = true;
                }
                if (clip.enabled === undefined) {
                    clip.enabled = true;
                }
            });

            const getStartTime = (clip) => {
                if (clip.selected_segment?.start !== undefined) {
                    return clip.selected_segment.start;
                }
                if (clip.segments?.[0]?.start !== undefined) {
                    return clip.segments[0].start;
                }
                return Infinity;
            };

            const sortedClips = [...project.clips]
                .sort((a, b) => getStartTime(a) - getStartTime(b));

            sortedClips.forEach((clip, index) => {
                clip.timeline_position = index;
            });
        }

        function getClipById(clipId) {
            return project?.clips?.find(c => c.id === clipId);
        }

        function getEffectiveTimes(clip) {
            const seg = clip.selected_segment || clip.segments?.[0];
            if (!seg) return { start: 0, end: 0 };
            
            return {
                start: clip.trim_start ?? seg.start,
                end: clip.trim_end ?? seg.end
            };
        }

        function getTimelineClips() {
            return project?.clips
                ?.filter(c => c.in_timeline)
                .sort((a, b) => (a.timeline_position || 0) - (b.timeline_position || 0)) || [];
        }

        function getPoolClips() {
            return project?.clips?.filter(c => !c.in_timeline) || [];
        }

        function renderClipPool() {
            const timelineClips = getTimelineClips();

            if (timelineClips.length === 0) {
                clipPoolList.innerHTML = '<div class="no-clips">No clips in timeline</div>';
                return;
            }

            const html = timelineClips.map((clip, index) => {
                const times = getEffectiveTimes(clip);
                const duration = (times.end - times.start).toFixed(1);
                const isSelected = selectedClipId === clip.id;
                const isDisabled = !clip.enabled;

                return `
                    <div class="pool-item ${isSelected ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}" 
                         data-clip-id="${clip.id}">
                        <span class="pool-item-name">${index + 1}. ${clip.name}</span>
                        <span class="pool-item-duration">${duration}s</span>
                    </div>
                `;
            }).join('');

            clipPoolList.innerHTML = html;

            document.querySelectorAll('.pool-item').forEach(item => {
                item.addEventListener('click', () => {
                    selectClip(item.dataset.clipId);
                });
            });
        }

        function renderTimelineCards() {
            const timelineClips = getTimelineClips();

            if (timelineClips.length === 0) {
                timelineCardsInner.innerHTML = '<div class="timeline-empty">No clips in timeline</div>';
                return;
            }

            const html = timelineClips.map((clip, index) => {
                const times = getEffectiveTimes(clip);
                const duration = (times.end - times.start).toFixed(1);
                const isSelected = selectedClipId === clip.id;
                const isDisabled = !clip.enabled;

                return `
                    <div class="timeline-card ${isSelected ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}"
                         data-clip-id="${clip.id}">
                        <div class="timeline-card-header">
                            <span class="timeline-card-name">${clip.name}</span>
                            <span class="timeline-card-pos">${index + 1}</span>
                        </div>
                        <div class="timeline-card-duration">${duration}s</div>
                    </div>
                `;
            }).join('');

            timelineCardsInner.innerHTML = html;

            document.querySelectorAll('.timeline-card').forEach(card => {
                card.addEventListener('click', () => {
                    const clip = getClipById(card.dataset.clipId);
                    if (clip) {
                        const times = getEffectiveTimes(clip);
                        mainVideo.currentTime = times.start;
                        mainVideo.play();
                    }
                });
            });
        }

        function renderWordLayer() {
            if (!transcript?.segments) return;

            let html = '';
            transcript.segments.forEach((seg, segIndex) => {
                if (!seg.words) return;
                
                seg.words.forEach((word, wordIndex) => {
                    html += `
                        <div class="word" 
                             data-segment="${segIndex}" 
                             data-word="${wordIndex}"
                             data-start="${word.start}"
                             data-end="${word.end}">
                            <div class="word-handle word-handle-left"></div>
                            <span>${word.text}</span>
                            <div class="word-handle word-handle-right"></div>
                        </div>
                    `;
                });
            });

            wordLayerInner.innerHTML = html;
            positionWords();
            attachWordDragHandlers();
        }

        function positionWords() {
            if (!waveformData) return;

            const duration = waveformData.duration;
            const containerWidth = waveformWidth || wordLayer.offsetWidth;

            document.querySelectorAll('.word').forEach(wordEl => {
                const start = parseFloat(wordEl.dataset.start);
                const end = parseFloat(wordEl.dataset.end);

                const left = (start / duration) * containerWidth;
                const width = Math.max(30, ((end - start) / duration) * containerWidth);

                wordEl.style.left = left + 'px';
                wordEl.style.width = width + 'px';
            });

            syncWordLayerWithWaveform();
        }

        function syncWordLayerWithWaveform() {
            const width = waveformWidth || wordLayer.offsetWidth;
            wordLayerInner.style.width = width + 'px';
            wordLayerInner.style.transform = `translateX(${-waveformPanX}px)`;
        }

        function attachWordDragHandlers() {
            document.querySelectorAll('.word').forEach(wordEl => {
                wordEl.addEventListener('mousedown', handleWordMouseDown);
            });
        }

        function handleWordMouseDown(e) {
            const wordEl = e.target.closest('.word');
            if (!wordEl) return;

            draggingWord = wordEl;
            wordDragStartX = e.clientX;
            wordDragStartTime = parseFloat(wordEl.dataset.start);
            wordDragEndTime = parseFloat(wordEl.dataset.end);

            if (e.target.classList.contains('word-handle-left')) {
                dragType = 'left';
            } else if (e.target.classList.contains('word-handle-right')) {
                dragType = 'right';
            } else {
                dragType = 'move';
            }

            wordEl.classList.add('dragging');
            e.preventDefault();
        }

        const MIN_WORD_DURATION = 0.15;
        const SAFE_SKIP_OFFSET = 0.05;
        const END_EPS = 0.03;

        function handleWordMouseMove(e) {
            if (!draggingWord) return;

            const deltaX = e.clientX - wordDragStartX;
            const deltaTime = (deltaX / waveformWidth) * waveformData.duration;

            const segIndex = parseInt(draggingWord.dataset.segment);
            const wordIndex = parseInt(draggingWord.dataset.word);
            const seg = transcript.segments[segIndex];
            const word = seg.words[wordIndex];

            const clip = selectedClipId ? getClipById(selectedClipId) : null;
            const clipTimes = clip ? getEffectiveTimes(clip) : { start: 0, end: waveformData.duration };
            const lowerBound = clipTimes.start;
            const upperBound = clipTimes.end;

            if (dragType === 'move') {
                const duration = wordDragEndTime - wordDragStartTime;
                const newStart = Math.max(lowerBound, Math.min(upperBound - duration, wordDragStartTime + deltaTime));
                word.start = newStart;
                word.end = newStart + duration;
            } else if (dragType === 'left') {
                const maxStart = word.end - MIN_WORD_DURATION;
                let newStart = wordDragStartTime + deltaTime;
                
                if (wordIndex > 0) {
                    const prevWord = seg.words[wordIndex - 1];
                    const prevMinEnd = prevWord.start + MIN_WORD_DURATION;
                    newStart = Math.max(prevMinEnd, newStart);
                } else {
                    newStart = Math.max(lowerBound, newStart);
                }
                
                newStart = Math.min(maxStart, newStart);
                
                if (wordIndex > 0) {
                    seg.words[wordIndex - 1].end = newStart;
                }
                word.start = newStart;
            } else if (dragType === 'right') {
                const minEnd = word.start + MIN_WORD_DURATION;
                let newEnd = wordDragEndTime + deltaTime;
                
                if (wordIndex < seg.words.length - 1) {
                    const nextWord = seg.words[wordIndex + 1];
                    const nextMaxStart = nextWord.end - MIN_WORD_DURATION;
                    newEnd = Math.min(nextMaxStart, newEnd);
                } else {
                    newEnd = Math.min(upperBound, newEnd);
                }
                
                newEnd = Math.max(minEnd, newEnd);
                
                if (wordIndex < seg.words.length - 1) {
                    seg.words[wordIndex + 1].start = newEnd;
                }
                word.end = newEnd;
            }

            draggingWord.dataset.start = word.start;
            draggingWord.dataset.end = word.end;
            
            positionWords();
            markUnsaved();
        }

        function handleWordMouseUp() {
            if (draggingWord) {
                draggingWord.classList.remove('dragging');
                draggingWord = null;
                dragType = null;
            }
        }

        document.addEventListener('mousemove', handleWordMouseMove);
        document.addEventListener('mouseup', handleWordMouseUp);

        function selectClip(clipId) {
            selectedClipId = clipId;
            renderClipPool();
            renderTimelineCards();
            renderEditor();
            loadVideoPreview(clipId);
        }

        function renderEditor() {
            if (!selectedClipId) {
                videoSection.classList.add('hidden');
                editorTranscript.textContent = '-';
                editorStartTime.textContent = '-';
                editorEndTime.textContent = '-';
                editorDuration.textContent = '-';
                return;
            }

            const clip = getClipById(selectedClipId);
            const seg = clip?.selected_segment || clip?.segments?.[0];
            if (!clip || !seg) {
                videoSection.classList.add('hidden');
                return;
            }

            videoSection.classList.remove('hidden');

            const times = getEffectiveTimes(clip);
            const duration = times.end - times.start;

            editorTitle.textContent = clip.name;
            editorTranscript.textContent = seg.text || '-';
            editorStartTime.textContent = formatTime(times.start);
            editorEndTime.textContent = formatTime(times.end);
            editorDuration.textContent = formatDuration(duration);

            toggleEnabledBtn.textContent = clip.enabled ? 'Disable' : 'Enable';
            toggleEnabledBtn.classList.toggle('btn-success', !clip.enabled);

            requestAnimationFrame(() => {
                renderFullWaveform(clip);
            });
        }

        function renderFullWaveform(clip) {
            const rect = waveformWrapper.getBoundingClientRect();
            
            if (rect.width === 0 || rect.height === 0) {
                requestAnimationFrame(() => renderFullWaveform(clip));
                return;
            }

            const peaks = waveformData.peaks;
            const duration = waveformData.duration;

            waveformWidth = rect.width * waveformZoom;
            waveformCanvasContainer.style.width = waveformWidth + 'px';

            waveformCanvas.width = waveformWidth * window.devicePixelRatio;
            waveformCanvas.height = rect.height * window.devicePixelRatio;
            waveformCanvas.style.width = waveformWidth + 'px';
            waveformCanvas.style.height = rect.height + 'px';

            waveformCanvasContainer.style.transform = `translateX(${-waveformPanX}px)`;

            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, waveformWidth, rect.height);

            const peaksPerPixel = peaks.length / waveformWidth;
            const centerY = rect.height / 2;

            ctx.fillStyle = '#2a4a6a';
            for (let x = 0; x < waveformWidth; x++) {
                const peakIndex = Math.floor(x * peaksPerPixel);
                const peak = peaks[peakIndex] || 0;
                const barHeight = peak * rect.height * 0.95;
                ctx.fillRect(x, centerY - barHeight / 2, 1, barHeight);
            }

            if (clip) {
                const times = getEffectiveTimes(clip);
                const startX = (times.start / duration) * waveformWidth;
                const endX = (times.end / duration) * waveformWidth;

                ctx.fillStyle = 'rgba(15, 15, 26, 0.6)';
                ctx.fillRect(0, 0, startX, rect.height);
                ctx.fillRect(endX, 0, waveformWidth - endX, rect.height);

                ctx.strokeStyle = '#4cc9f0';
                ctx.lineWidth = 2;
                ctx.strokeRect(startX, 0, endX - startX, rect.height);

                trimStart.style.left = (startX - waveformPanX) + 'px';
                trimEnd.style.left = (endX - 12 - waveformPanX) + 'px';

                if (clip.deleted_regions && clip.deleted_regions.length > 0) {
                    ctx.fillStyle = 'rgba(240, 80, 80, 0.4)';
                    clip.deleted_regions.forEach(region => {
                        const regionStartX = (region.start / duration) * waveformWidth;
                        const regionEndX = (region.end / duration) * waveformWidth;
                        ctx.fillRect(regionStartX, 0, regionEndX - regionStartX, rect.height);
                    });
                }
            }

            renderDeletedRegionElements(clip);
            waveformZoomInfo.textContent = `${waveformZoom.toFixed(1)}x`;
            updatePlayheadPosition();
            updateScrollbar();
            positionWords();
        }

        function renderDeletedRegionElements(clip) {
            waveformWrapper.querySelectorAll('.deleted-region').forEach(el => el.remove());
            
            if (!clip || !clip.deleted_regions) return;
            
            const duration = waveformData.duration;
            
            clip.deleted_regions.forEach((region, index) => {
                const el = document.createElement('div');
                el.className = 'deleted-region';
                el.dataset.regionIndex = index;
                
                const startX = (region.start / duration) * waveformWidth - waveformPanX;
                const endX = (region.end / duration) * waveformWidth - waveformPanX;
                
                el.style.left = startX + 'px';
                el.style.width = (endX - startX) + 'px';
                
                el.addEventListener('dblclick', () => {
                    clip.deleted_regions.splice(index, 1);
                    markUnsaved();
                    renderFullWaveform(clip);
                });
                
                waveformWrapper.appendChild(el);
            });
        }

        function updatePlayheadPosition() {
            if (!mainVideo.timeStart && mainVideo.timeStart !== 0) return;
            if (!waveformData) return;

            const duration = waveformData.duration;
            const currentTime = mainVideo.currentTime;
            const x = (currentTime / duration) * waveformWidth;

            playhead.style.left = (x - waveformPanX) + 'px';
        }

        function highlightCurrentWord(time) {
            document.querySelectorAll('.word.active').forEach(el => el.classList.remove('active'));

            if (!transcript?.segments) return;

            for (const seg of transcript.segments) {
                if (!seg.words) continue;
                for (const word of seg.words) {
                    if (time >= word.start && time <= word.end) {
                        const wordEl = document.querySelector(
                            `.word[data-segment="${transcript.segments.indexOf(seg)}"][data-word="${seg.words.indexOf(word)}"]`
                        );
                        if (wordEl) {
                            wordEl.classList.add('active');
                        }
                        return;
                    }
                }
            }
        }

        waveformWrapper.addEventListener('wheel', (e) => {
            e.preventDefault();

            const rect = waveformWrapper.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const oldZoom = waveformZoom;

            if (e.deltaY < 0) {
                waveformZoom = Math.min(50, waveformZoom * 1.25);
            } else {
                waveformZoom = Math.max(1, waveformZoom / 1.25);
            }

            const zoomRatio = waveformZoom / oldZoom;
            waveformPanX = mouseX - (mouseX - waveformPanX) * zoomRatio;

            const projectedWidth = rect.width * waveformZoom;
            const maxPan = Math.max(0, projectedWidth - rect.width);
            waveformPanX = Math.max(0, Math.min(maxPan, waveformPanX));

            const clip = selectedClipId ? getClipById(selectedClipId) : null;
            renderFullWaveform(clip);
        }, { passive: false });

        waveformWrapper.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('trim-handle')) return;
            if (e.target.closest('.word')) return;
            if (e.target.classList.contains('deleted-region')) return;

            const rect = waveformWrapper.getBoundingClientRect();
            const x = e.clientX - rect.left + waveformPanX;
            
            isSelecting = true;
            selectionStartX = e.clientX;
            selectionStartTime = (x / waveformWidth) * waveformData.duration;
            selectionEndTime = selectionStartTime;
            
            waveformSelection.style.display = 'block';
            updateSelectionRect();
        });

        function updateSelectionRect() {
            const rect = waveformWrapper.getBoundingClientRect();
            const startX = (selectionStartTime / waveformData.duration) * waveformWidth - waveformPanX;
            const endX = (selectionEndTime / waveformData.duration) * waveformWidth - waveformPanX;
            
            const left = Math.max(0, Math.min(startX, endX));
            const width = Math.abs(endX - startX);
            
            waveformSelection.style.left = left + 'px';
            waveformSelection.style.width = width + 'px';
        }

        document.addEventListener('mousemove', (e) => {
            if (isSelecting) {
                const rect = waveformWrapper.getBoundingClientRect();
                const x = e.clientX - rect.left + waveformPanX;
                selectionEndTime = Math.max(0, Math.min((x / waveformWidth) * waveformData.duration, waveformData.duration));
                updateSelectionRect();
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (isSelecting) {
                isSelecting = false;
                waveformSelection.style.display = 'none';
                
                const duration = Math.abs(selectionEndTime - selectionStartTime);
                if (duration > 0.1 && selectedClipId) {
                    const clip = getClipById(selectedClipId);
                    if (clip) {
                        if (!clip.deleted_regions) clip.deleted_regions = [];
                        const start = Math.min(selectionStartTime, selectionEndTime);
                        const end = Math.max(selectionStartTime, selectionEndTime);
                        clip.deleted_regions.push({ start: roundTo(start, 3), end: roundTo(end, 3) });
                        mergeDeletedRegions(clip);
                        markUnsaved();
                        renderFullWaveform(clip);
                    }
                }
            }
        });

        function roundTo(num, decimals) {
            return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
        }

        function mergeDeletedRegions(clip) {
            if (!clip.deleted_regions || clip.deleted_regions.length <= 1) return;
            
            clip.deleted_regions.sort((a, b) => a.start - b.start);
            const merged = [clip.deleted_regions[0]];
            
            for (let i = 1; i < clip.deleted_regions.length; i++) {
                const current = clip.deleted_regions[i];
                const last = merged[merged.length - 1];
                
                if (current.start <= last.end) {
                    last.end = Math.max(last.end, current.end);
                } else {
                    merged.push(current);
                }
            }
            
            clip.deleted_regions = merged;
        }

        waveformScrollbarThumb.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isDraggingScrollbar = true;
            scrollbarDragStartX = e.clientX;
            scrollbarDragStartPan = waveformPanX;
            waveformScrollbarThumb.classList.add('dragging');
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingScrollbar) {
                const rect = waveformWrapper.getBoundingClientRect();
                const trackRect = waveformScrollbar.querySelector('.waveform-scrollbar-track').getBoundingClientRect();
                
                const deltaX = e.clientX - scrollbarDragStartX;
                const panRatio = deltaX / (trackRect.width - waveformScrollbarThumb.offsetWidth);
                const maxPan = Math.max(0, waveformWidth - rect.width);
                
                waveformPanX = Math.max(0, Math.min(maxPan, scrollbarDragStartPan + panRatio * maxPan));
                
                const clip = selectedClipId ? getClipById(selectedClipId) : null;
                renderFullWaveform(clip);
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDraggingScrollbar) {
                isDraggingScrollbar = false;
                waveformScrollbarThumb.classList.remove('dragging');
            }
        });

        function updateScrollbar() {
            const rect = waveformWrapper.getBoundingClientRect();
            const trackWidth = rect.width - 16;
            
            if (waveformZoom <= 1) {
                waveformScrollbarThumb.style.width = '100%';
                waveformScrollbarThumb.style.left = '0';
            } else {
                const thumbWidth = Math.max(20, (rect.width / waveformWidth) * trackWidth);
                const maxPan = Math.max(1, waveformWidth - rect.width);
                const thumbLeft = (waveformPanX / maxPan) * (trackWidth - thumbWidth);
                
                waveformScrollbarThumb.style.width = thumbWidth + 'px';
                waveformScrollbarThumb.style.left = thumbLeft + 'px';
            }
        }

        function seekWhenReady(video, targetTime, callback) {
            console.log('[seekWhenReady] target:', targetTime.toFixed(3), 'seekable.length:', video.seekable.length);
            
            const trySeek = () => {
                if (video.seekable.length > 0) {
                    const start = video.seekable.start(0);
                    const end = video.seekable.end(0);
                    console.log('[seekWhenReady] seekable range:', start.toFixed(3), '-', end.toFixed(3));
                    if (targetTime >= start && targetTime <= end) {
                        console.log('[seekWhenReady] target in range, seeking to:', targetTime.toFixed(3));
                        video.currentTime = targetTime;
                        if (callback) callback();
                        return true;
                    }
                }
                return false;
            };

            if (!trySeek()) {
                console.log('[seekWhenReady] target not in range yet, waiting for progress...');
                const checkOnProgress = () => {
                    if (trySeek()) {
                        video.removeEventListener('progress', checkOnProgress);
                    }
                };
                video.addEventListener('progress', checkOnProgress);
                
                video.addEventListener('canplay', function onCanPlay() {
                    video.removeEventListener('canplay', onCanPlay);
                    trySeek();
                });
            }
        }

        function loadVideoPreview(clipId) {
            console.log('[loadVideoPreview] called with clipId:', clipId);
            console.trace('[loadVideoPreview] stack trace');
            
            const clip = getClipById(clipId);
            const seg = clip?.selected_segment || clip?.segments?.[0];
            if (!clip || !seg) return;

            const times = getEffectiveTimes(clip);
            console.log('[loadVideoPreview] times.start:', times.start, 'times.end:', times.end);

            mainVideo.timeStart = times.start;
            mainVideo.timeEnd = times.end;

            videoInfoTitle.textContent = clip.name;
            videoInfoTime.textContent = `${formatTimeShort(times.start)} - ${formatTimeShort(times.end)}`;

            const targetSrc = '../../data/video_combined.mp4';
            const srcChanged = !mainVideo.src || !mainVideo.src.includes('video_combined.mp4');
            console.log('[loadVideoPreview] srcChanged:', srcChanged, 'currentSrc:', mainVideo.src);
            
            if (srcChanged) {
                mainVideo.onloadedmetadata = () => {
                    console.log('[loadVideoPreview] onloadedmetadata, will seek when ready to:', times.start);
                    seekWhenReady(mainVideo, times.start);
                    mainVideo.onloadedmetadata = null;
                };
                mainVideo.src = targetSrc;
            } else {
                console.log('[loadVideoPreview] same src, seeking when ready to:', times.start);
                seekWhenReady(mainVideo, times.start);
            }
        }

        mainVideo.addEventListener('timeupdate', () => {
            const clip = selectedClipId ? getClipById(selectedClipId) : null;
            const start = mainVideo.timeStart;
            const end = mainVideo.timeEnd;
            const currentTime = mainVideo.currentTime;
            const lastTime = mainVideo._lastTime || currentTime;

            console.log(
                '[TU]',
                't', currentTime.toFixed(3),
                'lt', lastTime.toFixed(3),
                'start', start.toFixed(3),
                'end', end.toFixed(3),
                'deleted', (clip?.deleted_regions?.length || 0),
                'queue', previewQueue.length
            );

            if (currentTime >= end - END_EPS) {
                console.log('[TU] end guard fired');
                if (previewQueue.length > 0) {
                    previewIndex++;
                    playNextInQueue();
                    return;
                }
                mainVideo.pause();
                mainVideo.currentTime = end;
                mainVideo._lastTime = end;
                return;
            }

            if (clip && clip.deleted_regions && clip.deleted_regions.length > 0) {
                const effectiveRegions = clip.deleted_regions
                    .map(r => ({
                        start: Math.max(r.start, start),
                        end: Math.min(r.end, end)
                    }))
                    .filter(r => r.end > r.start);

                let t = currentTime;
                let lt = lastTime;
                let skipped = false;

                while (true) {
                    let didSkip = false;

                    for (const region of effectiveRegions) {
                        const inRegion = t >= region.start && t < region.end;
                        const enteredRegion = lt < region.start && t >= region.start && t < region.end;
                        const jumpedPastRegion = lt < region.start && t >= region.end && t < end - END_EPS;

                        if (inRegion || enteredRegion || jumpedPastRegion) {
                            let skipTarget = Math.min(region.end + SAFE_SKIP_OFFSET, end - SAFE_SKIP_OFFSET);
                            
                            console.log('[TU] skip to', skipTarget.toFixed(3), 'region was', region.start.toFixed(3), '-', region.end.toFixed(3));
                            
                            if (skipTarget >= end) {
                                if (previewQueue.length > 0) {
                                    previewIndex++;
                                    playNextInQueue();
                                    return;
                                }
                                mainVideo.pause();
                                mainVideo.currentTime = end;
                                mainVideo._lastTime = end;
                                return;
                            }
                            
                            mainVideo.currentTime = skipTarget;
                            mainVideo._lastTime = skipTarget;
                            lt = skipTarget;
                            t = skipTarget;
                            didSkip = true;
                            skipped = true;
                            break;
                        }
                    }

                    if (!didSkip) break;
                }

                if (skipped) {
                    updatePlayheadPosition();
                    highlightCurrentWord(mainVideo.currentTime);
                    return;
                }
            }

            mainVideo._lastTime = currentTime;
            updatePlayheadPosition();
            highlightCurrentWord(currentTime);
        });

        mainVideo.addEventListener('seeking', () => {
            console.log('[VIDEO EVENT] seeking to:', mainVideo.currentTime.toFixed(3));
            console.trace('[SEEKING STACK TRACE]');
        });

        mainVideo.addEventListener('seeked', () => {
            console.log('[VIDEO EVENT] seeked to:', mainVideo.currentTime.toFixed(3));
        });

        mainVideo.addEventListener('loadedmetadata', () => {
            console.log('[VIDEO EVENT] loadedmetadata, currentTime:', mainVideo.currentTime.toFixed(3));
        });

        mainVideo.addEventListener('canplay', () => {
            console.log('[VIDEO EVENT] canplay, currentTime:', mainVideo.currentTime.toFixed(3));
        });

        mainVideo.addEventListener('loadstart', () => {
            console.log('[VIDEO EVENT] loadstart, src:', mainVideo.src);
        });

        trimStart.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            isDraggingTrim = 'start';
            trimStart.classList.add('dragging');
        });

        trimEnd.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            isDraggingTrim = 'end';
            trimEnd.classList.add('dragging');
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingTrim || !selectedClipId) return;

            const clip = getClipById(selectedClipId);
            if (!clip) return;

            const rect = waveformWrapper.getBoundingClientRect();
            const x = e.clientX - rect.left + waveformPanX;

            const duration = waveformData.duration;
            const ratio = Math.max(0, Math.min(1, x / waveformWidth));
            const newTime = ratio * duration;

            const times = getEffectiveTimes(clip);

            console.log('[TRIM DRAG] isDraggingTrim:', isDraggingTrim, 'newTime:', newTime.toFixed(3), 'x:', x.toFixed(0), 'waveformWidth:', waveformWidth);

            if (isDraggingTrim === 'start') {
                clip.trim_start = Math.max(0, Math.min(newTime, times.end - 0.1));
                console.log('[TRIM DRAG] set trim_start to:', clip.trim_start.toFixed(3));
            } else {
                clip.trim_end = Math.min(duration, Math.max(newTime, times.start + 0.1));
                console.log('[TRIM DRAG] set trim_end to:', clip.trim_end.toFixed(3));
            }

            markUnsaved();
            renderFullWaveform(clip);
        });

        document.addEventListener('mouseup', () => {
            if (isDraggingTrim) {
                isDraggingTrim = null;
                trimStart.classList.remove('dragging');
                trimEnd.classList.remove('dragging');

                if (selectedClipId) {
                    loadVideoPreview(selectedClipId);
                    renderEditor();
                }
            }
        });

        splitBtn.addEventListener('click', () => {
            if (!selectedClipId) return;

            const clip = getClipById(selectedClipId);
            const seg = clip?.selected_segment || clip?.segments?.[0];
            if (!clip || !seg) return;

            const times = getEffectiveTimes(clip);
            const splitPoint = mainVideo.currentTime;

            if (splitPoint <= times.start || splitPoint >= times.end) {
                alert('Position playhead within the clip to split');
                return;
            }

            const clip1 = JSON.parse(JSON.stringify(clip));
            clip1.id = `${clip.id}_split_${Date.now()}_1`;
            clip1.name = `${clip.name} (1)`;
            clip1.trim_end = splitPoint;
            clip1.timeline_position = clip.timeline_position;
            clip1.split_parent_id = clip.id;

            const clip2 = JSON.parse(JSON.stringify(clip));
            clip2.id = `${clip.id}_split_${Date.now()}_2`;
            clip2.name = `${clip.name} (2)`;
            clip2.trim_start = splitPoint;
            clip2.timeline_position = clip.timeline_position + 0.5;
            clip2.split_parent_id = clip.id;

            clip.in_timeline = false;
            clip.timeline_position = null;

            project.clips.push(clip1, clip2);

            selectedClipId = clip1.id;

            markUnsaved();
            renderClipPool();
            renderTimelineCards();
            renderEditor();
            loadVideoPreview(clip1.id);
        });

        toggleEnabledBtn.addEventListener('click', () => {
            if (!selectedClipId) return;

            const clip = getClipById(selectedClipId);
            if (!clip) return;

            clip.enabled = !clip.enabled;

            markUnsaved();
            renderClipPool();
            renderTimelineCards();
            renderEditor();
        });

        previewAllBtn.addEventListener('click', () => {
            const timelineClips = getTimelineClips().filter(c => c.enabled);
            if (timelineClips.length === 0) {
                alert('No clips in timeline to preview');
                return;
            }

            previewQueue = timelineClips;
            previewIndex = 0;
            playNextInQueue();
        });

        function playNextInQueue() {
            if (previewIndex >= previewQueue.length) {
                previewQueue = [];
                previewIndex = 0;
                return;
            }

            const clip = previewQueue[previewIndex];
            const times = getEffectiveTimes(clip);

            selectedClipId = clip.id;
            renderClipPool();
            renderTimelineCards();
            renderEditor();

            mainVideo.timeStart = times.start;
            mainVideo.timeEnd = times.end;

            const targetSrc = '../../data/video_combined.mp4';
            const srcChanged = !mainVideo.src || !mainVideo.src.includes('video_combined.mp4');
            
            if (srcChanged) {
                mainVideo.onloadedmetadata = () => {
                    seekWhenReady(mainVideo, times.start, () => {
                        mainVideo.play();
                    });
                    mainVideo.onloadedmetadata = null;
                };
                mainVideo.src = targetSrc;
            } else {
                seekWhenReady(mainVideo, times.start, () => {
                    mainVideo.play();
                });
            }

            mainVideo.onended = () => {
                previewIndex++;
                playNextInQueue();
            };
        }

        function exportEDL() {
            const timelineClips = getTimelineClips().filter(c => c.enabled);
            if (timelineClips.length === 0) {
                alert('No clips to export');
                return;
            }

            let edl = 'TITLE: Content Tools Export\n';
            edl += 'FCM: NON-DROP FRAME\n\n';

            let timelineTime = 0;

            timelineClips.forEach((clip, i) => {
                const times = getEffectiveTimes(clip);
                const duration = times.end - times.start;
                const seg = clip.selected_segment || clip.segments?.[0];

                const clipIn = formatEDLTime(times.start);
                const clipOut = formatEDLTime(times.end);
                const recIn = formatEDLTime(timelineTime);
                const recOut = formatEDLTime(timelineTime + duration);

                edl += `${String(i + 1).padStart(3, '0')}  AX       AA/V  C        ${clipIn} ${clipOut} ${recIn} ${recOut}\n`;
                edl += `* FROM CLIP NAME: ${clip.name}\n`;
                edl += `* COMMENT: ${seg?.text?.substring(0, 60) || ''}\n\n`;

                timelineTime += duration;
            });

            const blob = new Blob([edl], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'assembly.edl';
            a.click();
            URL.revokeObjectURL(url);
        }

        function formatEDLTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const f = Math.floor((seconds % 1) * 30);
            return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}:${String(f).padStart(2, '0')}`;
        }

        exportBtn.addEventListener('click', exportEDL);

        async function saveProject() {
            try {
                const projectData = {
                    ...project,
                    transcript: transcript
                };

                const response = await fetch('../../data/project.json', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(projectData, null, 2)
                });

                if (!response.ok) {
                    throw new Error('Failed to save');
                }

                markSaved();
                console.log('[Assemble] Project saved with word timings');
            } catch (e) {
                const projectData = {
                    ...project,
                    transcript: transcript
                };
                const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'project.json';
                a.click();
                URL.revokeObjectURL(url);
                markSaved();
            }
        }

        saveBtn.addEventListener('click', saveProject);

        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        window.addEventListener('resize', () => {
            if (selectedClipId) {
                const clip = getClipById(selectedClipId);
                if (clip) {
                    requestAnimationFrame(() => renderFullWaveform(clip));
                }
            } else if (waveformData) {
                renderFullWaveform(null);
            }
        });

        loadData();
    </script>
</body>
</html>
